# Contributing

- [Основное](#основное)
- [Создание Pull Request](#создание-pull-request)
- [Описания коммитов](#описания-коммитов)
- [Процесс прохода Code Review](#процесс-прохода-code-review)
- [Договоренности по написанию кода](#договоренности-по-написанию-кода)
  - [Правила именования переменных и функций](#правила-именования-переменных-и-функций)
  - [Написание функций](#написание-функций)
  - [Общие правила](#общие-правила)
- [Разработка безопасного кода](#разработка-безопасного-кода)
- [Файлы](#файлы)
- [Фишки и лайфхаки Dream Maker](#фишки-и-лайфхаки-dream-maker)

**[Процесс работы с иссуями](https://github.com/ChaoticOnyx/OnyxBay/blob/dev/docs/issues_processing.md)** - гайд по иссуям и плашкам в нашем репозитории.

# Основное

* Официальные языки нашего сообщества - русский и английский. Коммиты, пулл реквесты, иссуи - все можно писать на обоих языках. Однако в исходных кодах русский язык запрещен в связи с проблемами, связанными с кодировками.
* Мы ожидаем, что вы поможете нам поддерживать код, который вы добавили. Скорее всего мы к вам обратимся в случае возникновения каких-то проблем, связанных с вашими изменениями, в том числе рантаймами или багами.

# Создание Pull Request

Здесь приведен небольшой чек-лист важных вещей, на которые обязательно нужно обращать внимание при открытии Pull Request-а. Пренебрежение этим разделом может увеличить время проверки ваших изменений и принятия в сборку вплоть до бесконечности!

* **Заголовок ПРа - цель его изменений.**  У любого Pull Request должна быть конкретная цель, которая должна быть указана в заголовке. Pull Request не должен содержать изменений, которые не относятся к указанной цели. Если цель Pull Request-а слишком большая, чтобы уместить её в одном заголовке - подумайте над тем, чтобы разбить свой Pull Request на более мелкие части.
* **Изменения востребованы.** Перед началом разработки убедитесь, что то, что вы хотите сделать - востребовано и будет принято. Для этого нужно либо обсудить изменения с текущими разработчиками сервера или геймдизайнером. Также изменения очевидно востребованы, если на них есть соответствующий иссуй, проверенный командой сервера. Чтобы ваши изменения ТОЧНО были приняты - лучше убедиться в том, что у вас есть соответстующий иссуй с подтверждением, так как любые договоренности в дискорде могут потеряться или оказаться неактуальными.
* **Подробное описание.** В описании Pull Request-а должно быть подробное описание того, зачем он нужен и что в нем происходит. Pull Request не должен содержать изменений, о которых ничего не написано в описании.
* **Привяжите иссуи.** Если Pull Request решает какие-то иссуи, то они должны быть указаны в описании специальным образом, например, `close #23`, чтобы Github смог их автоматически привязать к вашим изменениям. Подробнее можно почитать тут: https://help.github.com/articles/closing-issues-via-commit-messages.
* **Проверьте свой код.** Открывайте Pull Request только если вы уверены в его работоспособности. Это означает, что вы проверили каждую строчку своих изменений, а также **проверили свои изменения локально**, запустив сервер на своем компьютере. Если что-то невозможно проверить полностью или вы считаете, что на какую-то часть изменений нужно обратить пристальное внимание проверяющих, то укажите это отдельно в описании. Конечно мы также будем проверять ваши изменения, но вы не должны полагаться на то, что ваши баги заметит кто-то другой и исправит за вас.
* **Ваш код соответствует принятым договоренностям по написанию кода.** Подробнее смотрите раздел "Договоренности по написанию кода" ниже.

# Описания коммитов

Главная цель правильного именования и описания коммитов - упростить процесс чтения истории git. Чем понятнее написаны комментарии к коммитам, тем проще находить причины багов.

Коммиты следует именовать по следующей схеме:

```
action(area): short one-line description

long multiline description

related items
```

* **action** - тип действия, которое совершается в коммите. Например, fix, feat, refact, tweak, delete, docs и т.д. Отвечает на вопрос "Что делаем?"
* **area** - область кода, в которой происходит действие. Например, atmospherics, MC, changeling, exodus и т.д.
* **related items** - иссуи, которых касается коммит. Еще какие-то ссылки, которые могут относиться к PR-у. В случае иссуев обязательно использование [ключевых слов Github](https://help.github.com/articles/closing-issues-via-commit-messages) для автоматического связывания коммита с иссуями.

Пример хорошего описания коммита:

```
tweak(vortex): more server-friendly vortex behavior and other tweaks

Rebalance.
Also fixes issue with O(N) intended malfunctions for 'battle function' becoming O(N^unknown) due to malfunction calling itself on each iteration.
Therefore, base malfunction chance was raised a bit.
Charge costs multiplied, as there was no 'bluespace cell' with 10k total capacity when previous values were implemented.

PR #1766
close #1432
```

Еще раз отдельно обратим внимание на то, что коммиты можно писать на русском языке по той же схеме. Однако `area` и разные ключевые слова обязательно нужно писать на английском языке, согласно тому, как оно пишется в коде, чтобы всем было понятно какой части кода касаются ваши изменения.

# Процесс прохождения Code Review

* **Аппрув разработчиков.** Чтобы Pull Request был принят - он должен быть аппрувнут двумя активными разработчиками сервера.
* **Аппрув геймдизайнера.** Если в Pull Request есть изменения игровой логики, то он должен быть аппрувнут геймдизайнером сервера. Аппрув не нужен, если Pull Request выполнен в рамках иссуя, который был ранее аппрувнут геймдизайнером. Также аппрув не нужен для фикса багов и любых изменений, которые не затрагивают игровой опыт игроков (рефакторинг, оптимизации, фичи для администраторов и подобное).
* **Проверка на локальной сборке.** Принимаются только Pull Request-ы, проверенные локально. Если сам разработчик не проверяет свои изменения, то проверка проходит тщательнее, из-за чего принятие изменений затягивается.
* **Вливание изменений в основную ветку.** Если коммиты в PR соответствуют правилам именования, при мерже не возникает конфликтов и каждый коммит по отдельности не ломает сборку, то принимать следует с помощью rebase. Если коммиты в PR соответствуют правилам именования, но принять её с помощью rebase невозможно т.к. на каких-то коммитах из PR сборка сломана, или же из-за конфликтов, то принимать нужно с помощью merge. Если хотя бы один коммит в PR не соответствует правилам именования, то весь PR может быть принят только через squash с названием, соответствующим правилам.
* **Вливание изменений на сервер.** Ветка разработки называется `dev`. Перед обновлением серверов проверенные изменения из `dev` вливаются в `master`. В обоих ветках должна поддерживаться чистая история коммитов, которые соответствуют правилам именования. Сервера берут свой код из собственных веток, куда код вливается уже из `master`. В собственных ветках серверов история может портиться засчет ревертов, мержей и временных изменений (например, для ивентов). В связи с техническими особенностями хоста ветки серверов нельзя обновлять через force-push. На сервер изменения должны попадать вместе с чейнжлогом для максимального оповещения игроков о статусе разработки.

# Договоренности по написанию кода

## Правила именования переменных и функций

### Имена должны передавать намерения программиста

Имя переменной, функции или типа должно сообщить, почему эта переменная существует, что она делает и как используется. Если имя требует дополнительных комментариев, значит, оно не передает намерений программиста. Лучше написать, что именно измеряется и в каких именно единицах.

Не бойтесь использовать длинные имена: длинное содержательное имя лучше короткого невразумительного.

Пример хорошего названия переменной: days_since_creation;
Цель: убрать неочевидность.

### Избегайте неинформативных слов в названиях

Неинформативные слова избыточны. Слово variable никогда не должно встречаться в именах переменных. Слово object никогда не должно встречаться в именах объектов. Чем имя name_string лучше name? Разве имя может быть, скажем, вещественным числом?

### Избегайте сокращений, старайтесь выбирать удобопроизносимые имена

russian_to_utf намного лучше rustoutf.

### Выбирайте имена, удобные для поиска

Чем дольше время жизни переменной - тем длиннее должно быть её название. Однобуквенные имена могут использоваться только для локальных переменных в коротких методах.

### Имена типов

Имена типов должны представлять собой существительные и их комбинации: traitor, profession, id_card и request_parser. Старайтесь не использовать в именах классов такие слова, как manager, processor, data или info. Имя класса не должно быть глаголом.

### Имена функций

Имена методов представляют собой глаголы или глагольные словосочетания: explode_station, delete_ian, save и т. д. Методы чтения/записи образуются из значения и префикса get, set и is.

### Используйте абсолютные пути

DM позволяет писать код блоками:

```DM
datum
	datum1
		var
			varname1 = 1
			varname2
			static
				varname3
				varname4
		proc
			proc1()
				code
			proc2()
				code

		datum2
			varname1 = 0
			proc
				proc3()
					code
			proc2()
				..()
				code
```

Такой способ написания делает невозможным текстовый поиск функции или типа по коду. Единственное исключение - внутри блока описания типа можно определять переменные.

Тот же код, написанный правильно:

```DM
/datum/datum1
	var/varname1
	var/varname2
	var/static/varname3
	var/static/varname4

/datum/datum1/proc/proc1()
	code
/datum/datum1/proc/proc2()
	code
/datum/datum1/datum2
	varname1 = 0
/datum/datum1/datum2/proc/proc3()
	code
/datum/datum1/datum2/proc2()
	..()
	code
```

## Написание функций

### Компактность

* **Первое правило:** функции должны быть компактными.
* **Второе правило:** функции должны быть еще компактнее.

Серьезные программисты работающие в реальном мире ценой многих проб и ошибок вывели, что функции должны быть очень маленькими. Желательно, чтобы длина фукнции не превышала 20 строк. В условиях разработки SS13 кому-то это может показаться излишним, но даже в наших проектах можно заметить, что чем длиннее функция тем сложнее её поддерживать, тем больше в ней багов и тем меньшее количество людей хочет в неё лезть и с ней разбираться.

### Правило одной операции

Функция должна выполнять только одну операцию. Она должна выполнять ее хорошо. И ничего другого она делать не должна. Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта функция выполняет одну операцию.

### Функция не должна разбиваться на секции

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

### Разделение команд и запросов

Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно. Либо функция изменяет состояние объекта, либо возвращает информацию об этом объекте. Совмещение двух операций часто создает путаницу.

## Общие правила

### Комментарии

Закомметированный код запрещен.

Запрещены комментарии отвечающие на вопрос "Что делает этот код?". Вместо этого используете методы для увеличения читаемости кода выше, чтобы код объяснял себя сам. Разрешены комментарии отвечающие на вопрос "Зачем этот код нужен?".

Также можно писать комментарии типа "TODO" и "FIXME".

### Не избавляйтесь от проверки типов
Запрещено использовать оператор `:`. Всегда явно преобразуйте переменную к конкретному типу.

Плохой пример:
```DM
var/something_general_object = ...
something_general_object:specific_type_func()
```

Мы узнаем, что у something_general_object нет такой функции только когда запустим сервер. Более того, когда мы это узнаем - будет непонятным что это за тип, почему у него было этой функции и какой тип на самом деле ожидался. С другой стороны, в коде:

```DM
var/something_general_object
var/more/specified/type/O = object
ASSERT(istype(O)) // bad argument
O.specific_type_funс()
```

Мы явно указываем какой тип мы ожидаем и статически проверяем, что у этого типа есть такая функция.

### Используйте ASSERT для проверок аргументов функций

Если ваша функция расчитана на то, чтобы работать только с аргументами определенного типа или какими-то конкретными значениями - используйте ASSERT, чтобы явно это указать. Если, вдруг, случится так, что откуда-то в функцию приедет неожиданный аргумент - лучше сразу зарепортить об этом рантаймом и выйти из функции, чем пойти дальше, сделать что-то неожиданное и, может быть, даже не оставить следа о том, что фукнция сработала не так, как нужно.

Имейте в виду, что ASSERT генерирует рантайм, что ведет к выходу из функции с возвратом null. Функция выше по стеку продолжит свое выполнение с полученным null.

Плохой пример:

```DM
/datum/controller/subsystem/open_space/proc/add_turf(turf/T, ...)
	if(!isturf(T))
		return
	...
```

Если мы в функцию `add_turf` передали аргументом не turf - это очевидный баг. С таким вариантом реализации этот баг останется незамеченным и он может привести к неожиданным проблемам. Но если мы напишем так:

```DM
/datum/controller/subsystem/open_space/proc/add_turf(turf/T, ...)
	ASSERT(isturf(T))
	...
```

То мы все также выйдем из функции, вернув null, но при этом запишем рантайм, который мы увидим в логах, благодаря чему сможем обнаружить и пофиксить изначальный баг, который приводит к тому, что сюда аргументом передается неверный тип.

### Пути типов всегда должны начинаться с /
Например: `/datum/thing`, вместо `datum/thing`

### Пути типов всегда должны быть в нижнем регистре
Например: `/datum/thing/blue`, вместо `datum/thing/BLUE` или `datum/thing/Blue`

### Использование ключевого слова `var`
Локальные переменные всегда определяйте в формате `var/type/name`, вместо `var type/name`. В аргументах функций оно избыточно, поэтому всегда опускаем и пишем просто `type/name`. 

### Табы vs пробелы
Для индентации (отступ до текущего блока кода) всегда используем только табы. После индентации может быть выравнивание пробелами (не выравнивайте табами - иначе разъедется в редакторах с разной длиной таба).

### Избегайте дублирования кода
Когда вы копируете один и тот же код в разные места - появляется необходимость одинаково поддерживать этот код в двух местах. При любом изменении оригинального кода надо помнить о копии этого кода в другом месте и зачастую вносить изменения и туда.

Чтобы избежать подобных проблем используйте наследование объектов друг от друга или же просто вынесите необходимую логику в отдельную функцию.

### Предпочитайте `Initialize()` вместо `New()` для atom (объектов, размещаемых на карте).
Контроллеры, используемые в нашей сборке, должны справляться с длительными операциями и лагами, но они не могут контролировать то, что происходит во время загрузки карты, когда для всех объектов вызывается New. Для любых новых объектов, без явной необходимости, используйте `Initialize`, чтобы сделать все, что вы хотели сделать в `New`. Это уменьшает количество функций вызываемых на этапе загрузки карты. Чтобы узнать больше про то, как работает `Initialize`, смотрите https://github.com/ChaoticOnyx/OnyxBay/blob/dev/code/game/atoms.dm

**NB:** Важно понимать то, как работают Initialize и последовательность их выполнения относительно New, иначе можно словить приколы (см. https://github.com/ChaoticOnyx/OnyxBay/issues/3817). Initialize вызывается в /atom/New. Соответственно при создании объекта сначала вызывается New последнего типа в иерархии наследования. Дальше через ..() (если они, конечно, есть) последовательно вызываются New более ранних по иерархии типов вплоть до /atom/New, где вызывается /atom/Initialize, который точно также начинает выполняться с последнего переопределения в иерархии наследования объектов.

Таким образом получается, что в любом New, все что находится после ..() - вызывается после всех Initialize в цепочке наследования, а все что написано до ..() - работает перед всеми Initialize в цепочке наследования. Из этого следует, что если в вашей иерархии типов перемешиваются New и Initialize, то порядок их вызова может быть немного непредсказуемым, что вызывает приколы вроде перезаписи переменной, которая определяется в чайлдовом типе, в Initialize, значением из родителького объекта, из New. Пример и подробный разбор такой баги можно посмотреть здесь: https://github.com/ChaoticOnyx/OnyxBay/issues/3817 .

Если вы не очень поняли что написано выше, то просто следуйте одному простому правилу:

**Старайтесь не перемешивать New и Initialize в иерархиях объектов. Если меняете один New на Initialize - меняйте сразу всей иерархии. Если в иерархии используются New, то проще использовать New в новом объекте этой иерархии**, однако в плане производительности - лучше переписать всю иерархию на Initialize.

### Удаление объектов
Все объекты должны всегда удаляться с помощью `qdel`.

Использование `del` запрещено, так как эта функция запускает довольно требовательную процедуру поиска и обнуления ссылок на объект по всему коду.

Просто "бросать" объекты без явного удаления через `qdel` не рекомендуется, так как в таком случае не будет вызван Destroy, который, даже если еще не определен для конкретного объекта, кто-то может захотеть добавить позже.

Отдельно важно помнить про случаи с циклическими зависимостями, когда объекты хранят ссылки друг на друга циклически. Если такой цикл объектов просто удалить через qdel, то объекты никогда не будут удалены, так как механизм qdel работает просто через ожидание пока ссылки на объект закончатся (циклически объекты указывают друг на друга - поэтому ссылки никогда не закончатся). В таком случае нужно делать не только qdel всех объектов, но и занулять какую-то часть ссылок так, чтобы избавиться от цикла.

### Перемещайте объекты с помощью forceMove(newpos)
В отличие от `loc = newpos`, `forceMove` может переопределяться и в нем написано много важной логики, которая нужна при перемещении объектов из одного места в другое. 

### Не используйте магические значения
В коде не должно быть "брошенных" числовых/строчных или каких-либо еще значений, смысл которых неясен из контекста или которые могут быть переиспользованы. Определяйте их через макрос, если они нужны в глобальном скоупе, или создавайте локальную переменную с понятным названием.

Пример:
```DM
/datum/proc/do_the_thing(thing_to_do)
	switch(thing_to_do)
		if(1)
			(...)
		if(2)
			(...)
```
Здесь неясно, что означают "1" и "2"! Вместо этого можно было бы написать:
```DM
#define DO_THE_THING_REALLY_HARD 1
#define DO_THE_THING_EFFICIENTLY 2
/datum/proc/do_the_thing(thing_to_do)
	switch(thing_to_do)
		if(DO_THE_THING_REALLY_HARD)
			(...)
		if(DO_THE_THING_EFFICIENTLY)
			(...)
```
Так получается гораздо понятнее, что увеличивает читаемость вашего кода.

Еще пример:
```DM
/datun/gamemode/proc/create_events()
	events.Add(new /datum/event(90, list(/datum/role/hos)))
	events.Add(new /datum/event(50, list(/datum/role/officer)))
```

В примере понятно, что мы задаем ивенты для какого-то игрового режима, однако непонятно что за аргументы передаются внутрь - это как раз "магические" значения. Чтобы сделать понятнее, можно, например, явно указать переменные, которые мы присваиваем:

```DM
/datun/gamemode/proc/create_events()
	events.Add(new /datum/event(chance=90, requires_roles=list(/datum/role/hos)))
	events.Add(new /datum/event(chance=50, requires_roles=list(/datum/role/officer)))
```

### Операторы контроля выполнения
(if, while, for и другие)

* Все операторы контроля выполнения не должны содержать другого кода на той же строчке (`if (blah) return`)
* Все операторы контроля выполнения, сравнивающие переменную с каким-то значением, должны использовать формулу `переменная` `оператор` `значение`, не наоборот (например: `if (count <= 10)`, вместо `if (10 >= count)`)

### Оператор in
Оператор in имеет наименьший приоритет (это не указано в рефе), поэтому его всегда нужно заключать в скобки: `if(A && (A in foo_list))`.

### Оператор as запрещено использовать в проках, не использующихся как verb
Потому что не имеет смысла

### Используйте макросы оформления текста SPAN_NOTICE, SPAN_WARNING, SPAN_DANGER и другие
Вместо `to_chat(usr, "<span class="warning">[text]</span>")` используйте `to_chat(usr, SPAN_WARNING(text))`.

### Используйте ранний return
Не стоит строчить многоуровневые конструкции из блоков if, когда того же результата можно достичь ранним возвратом из функции

Вот так делать не стоит:
```DM
/datum/datum1/proc/proc1()
	if (thing1)
		do stuff
		if (!thing2)
			do more stuff
			if (thing3 == 30)
				do extra stuff
```
А так уже лучше:
```DM
/datum/datum1/proc/proc1()
	if (!thing1)
		return
	do stuff
	if (thing2)
		return
	do more stuff
	if (thing3 != 30)
		return
	do extra stuff
```

### TRUE/FALSE для логических значений
Во всех случаях, когда нужно логическое значение, вместо 1/0 используйте TRUE/FALSE.

### Global против static

В DM есть ключевое слово global, которое используется в двух случаях:

1. Внутри типа (или внутри функции) мы хотим определить переменную общую для всех объектов этого типа (для всех вызовов этой функции). (http://www.byond.com/docs/ref/#/var/global).
2. Внутри функции мы хотим использовать переменную из глобального скоупа, когда у нас в локальном скоупе уже есть переменная с таким же названием. (http://www.byond.com/docs/ref/#/proc/var/global) Так использовать global не стоит! См. следующее правило.

Так как в первом случае речь идет не о видимости переменной, а том, что она общая для разных экземпляров типа (вызовов функции), то название ключевого слова global может кого-то запутать. Поэтому вместо него в первом случае мы стараемся использовать ключевое слово static, которое отсутствует в документации, но полностью заменяет global в этом случае и лучше описывает суть происходящего.

Отдельно обратите внимание, что все переменные в BYOND имеют глобальную видимость с точки зрения доступа, поэтому global (и static) в глобальном скоупе не имеет смысла и запрещено.

### Избегайте глобальных переменных

Главная проблема глобальных переменных в том, что чем больше они используются, тем сложнее понять логику их изменения и поведения процессов, которые от них зависят. Поэтому глобальные переменные лучше вовсе не использовать. Однако, если вам все-таки очень нужна глобальная переменная, то, как минимум, создавайте их на контроллере глобальных переменных, что даст чуть больше возможностей для их дебага:

Там все просто - вместо глобальных перменных нужно всегда использовать макросы (ну и конечно же лучше всего вообще не использовать глобальные переменные). Пример с тг:

Вместо:
```DM
var/X
var/list/Y
var/datum/genitalia/Z
var/A = 42
var/list/B = list(burn = "witch")
var/datum/genitalia/C = MakeAPenis()
var/hub_password
```

Используйте:
```DM
GLOBAL_VAR(X)
GLOBAL_LIST(Y)
GLOBAL_DATUM(Z, /datum/genitalia)
GLOBAL_VAR_INIT(A, 42)
GLOBAL_LIST_INIT(B, list(burn = "witch"))
GLOBAL_DATUM_INIT(C, /datum/genitalia, MakeAPenis())
GLOBAL_PROTECT(hub_password)
```

### Избегайте использования генераторов списков
`range()`, `view()`, `hearers()`, `locate() [in world]`, `for(... [in world])` и подобные операции очень требовательные в плане производительности, поэтому должны импользоваться как можно реже. Зачастую их можно заменить глобальным списком объектов нужного типа.

### alert() и input(): изменение контекста после вызова
`alert()` и `input()` ждут реакции пользователя и пока они ждут, все окружение может поменяться: поля объекта, переменные вокруг и т.д. Учитывайте это и добавляйте дополнительные проверки по необходимости.

### addtimer() вместо spawn()/sleep()
Практика показывает, что `addtimer` лучше оптимизирован, чем встроенные spawn и sleep, плюс код, написанный с его использованием, гораздо проще дебажить.

## Разработка безопасного кода
* Всегда относитель к пользовательскому вводу так, как будто он намеренно пытается все сломать. Проверяйте пользовательский ввод на все случаи, которые не соответсвуют ожиданиям вашего кода. Для чисел проверяйте границы, для строк используйте escape-функции. Обратите внимание на функцию `sanitize`, которой удобно эскейпить вообще любой `input`, чтобы избежать ввод какого-то кода, который выполнится в браузере.
* Обязательно эскейптьте все команды к базе данных - используйте `sanitizeSQL` чтобы обработать весь текст от игроков и админов перед тем как передавать его в базу данных. Для чисел используйте `isnum`.
* Все вызовы топиков обязательно нужно проверять на их корректность. Такие вызовы могут быть подделаны со стороны клиента, поэтому их содержимым может быть что угодно!
* Скрывайте от игроков любую информацию, которая может быть использована для метагейма (даже такую простую, как количество игроков, которые нажали Declare, так как даже она может быть использована, чтобы вычислить текущий режим).
* Когда вы пишите код, который может каким-то образом влиять на раунд и генерировать *ВЕСЕЛЬЕ*, дважды проверьте, что такой функционал будет доступен только админам соответствующего ранга.

## Файлы
* Рантаймы не содержат полного пути до файла - поэтому избегайте одинаковых названий файлов даже в разных папках.
* Названия файлов не должны содержать пробелов или символов, которые придется эскейпить, указывая uri.
* Названия файлов и все пути всегда должны быть в нижнем регистре, чтобы избежать проблем, связанных с разным отношением к регистру в разных операционных системах.

## Фишки и лайфхаки Dream Maker
Как и любые другие языки, в BYOND есть свои особенности, которые стоит учитывать, чтобы писать более эффективный код. Тут описаны некоторые из них.

### In-To for-loops
`for(var/i = 1, i <= some_value, i++)` является стандартным способом писать циклы во многих языках программирования, однако в BYOND, внезапно, `for(var/i in 1 to some_value)` оказывается быстрее в плане производительности. (Обратите внимание, что `to` включает и левую, и правую границу).

ОДНАКО, если `some_value` или `i` меняются в течение цикла, или вы итерируете по элементам списка, длина которого изменяется, вы НЕ можете использовать этот тип цикла for.
